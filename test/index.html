<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <div class="container">
        <h1>客服系统 3.0.0</h1>
        <button onclick="test()">Submit\nxx</button>
    </div>
    <a href="test1.html">测试</a>
</body>
<script>
    // 1. document and style
    var log = document.getElementById("debug");
    if(!log){
        log = document.createElement("div");
        log.id = "debug";
        log.innerHTML = "<h1>Debug Log</h1>";
        var pre = document.createElement("pre");
        var text = document.createTextNode("Hello, \n my friend!");
        pre.appendChild(text);
        log.appendChild(pre);
        pre.style.display = 'none';
        pre.className = 'hide';
        document.body.appendChild(log);
    }

    // 2. XMlHttpRequest. A very simple demo.
    function test() {
        if (!window.XMLHttpRequest) return;
        var url = "getMoney.php" + "?id=" + encodeURIComponent('你好');
        var req = new XMLHttpRequest();
        req.open("GET", url);
        req.send();
    }

    // 3. Regular Expression
    var test = "testing: 1, 2, 3",coo;
    var pattern = /\d+/g;
    pattern.test(test); //true
    test.search(pattern); //9 首次匹配成功的位置
    test.match(pattern); //所有匹配组成的数组
    test.replace(pattern,"C");
    test.split(/\D+/); //["","1","2","3"]

    // 0,-0,null,undefined,"",NAN  假值==false
    //{},[] 真值==true
    //两个单独的对象 永远不相等

    // 4. escape(), encodeURI(), encodeURIComponent()
    // escape()除开ASCII字母数字和特定符号外，对字符串全部进行转义编码，这样可以在所有计算机上读取该字符串,但不适合URL编码
    // encodeURI() 用于编码整个URL
    // encodeURIComponent() 用于编码单个URL请求参数时，比较常用

    // 5. 算术运算：Math
    // Math.pw(); Math.round(); Math.ceil(); Math.floor(); Math.abs(); Math.max.min(x,y,z)
    // Math.random(); Math.PI; Math.E; Math.sqrt(3); Math.pow(3,1/3); Math.sin.atan();
    // Math.log(10); Math.log(100)/Math.LN10/Math.LN2; Math.exp(3);

    // 6. Date()
    // new Date() - new Date(2016,10,14,14,4,0)
    // date.getFullYear().getMonth().getDate().getDay().getHours().getUTCHours()

    // 7. String
    // s.length().charAt(0).substring(1,4).slice().indexOf().lastIndexOf().split().replace().toUpperCase()
    //

    // 8. 和其他很多解释性语言一样，JavaScript同样可以解释运行由JavaScript源代码组成的字符串，并产生一个值。
    // eval();
    // for(initialize; test; increment){ statement; }
    // debugger 语句通常什么也不做，只是程序运行时，产生一个断点，JS执行会停止在断点的位置，这时可以使用调试器输出变量的值，检查调用栈等。注意debugger语句不会启动调试器。


    // 9. 对象原型 Object.prototype
    // 9.1 Object.create(Object.prototype) = {} = new Object()
    // 将对象或数组赋值给一个变量，仅仅是赋值的引用值
    // sort(); no need to pass parameter
    // javascript 的对象都是关联数组 associative array
    // 属性访问错误问题：如果试图访问不存在对象的属性时 会报错；写IF 太麻烦；可以这样写：arr&&arr.subtitle&&arr.subtitle.length
    // 检查属性：in, hasOwnProperty, propertyIsNumerable
    // 删除一个不存在的属性，不会报错
    // 对象深拷贝，但是会丢失对象方法：JSON.parse(JSON.stringify(obj));

    // 10. 数组
    // [,,]只有两个元素，undefined
    // 10.1 push().pop() shift().unshift()
    // 10.2 join() reverse() sort() concat()
    // slice()返回指定数组的一个片段或子数组，不会修改调用数组 slice(start,end)
    // splice() 插入和删除数组元素的通用方法 splice(index,count,element...) 区别于concat,splice 会插入数组本身
    // 10.3 ECMAScript 5中的数组方法：
    // 10.3.1 forEach(fun(value,index,array)) map()但是map里的函数应该有返回值
    // 10.3.2 filter()返回调用数组的一个子集，但是需要注意的是它会跳过稀疏数组，它总是返回抽秘数组，可用于压缩数组空缺，删除undefined 和 null 元素
    // 10.3.3 every() some() 数组的逻辑判定 返回true or false
    // 10.3.4 reduce() 求和，求积求，最大值 reduceRight()只是数组索引由高到低
    // array.reduce(fun(x,y){ return x+y },init) 没有初始值 就直接使用数组第一二个元素，如果只有一个元素且没有指定初始值或者空数组和有初始值，则只是简单返回那个值而不会调用化简函数
    // 10.3.5 indexOf() lastIndexOf() 返回指定值的索引 如果无匹配则返回-1
    // 10.3.6 数组类型 typeof: not working; instanceof:只能用于简单的情况; ECMAScript5 可以用 isArray; ECMAScript3及以下:
    var isArray = Function.isArray || function(o){
                return typeof o === "object" && Object.prototype.toString.call(o) === "[object Array]"
            };
    // 13--------------------
    // 同源策略
    // JavaScript不能做什么：
    // 1.客户端JS没有权限来写入或删除客户计算机上的任意文件或列出文件列表
    // 2.防止XSS攻击方式，动态创建文档内容之前从中移除HTML标签
    var _html = "html";
    _html = _html.replace(/</g,"&lt;").replace(/>/g,"&gt;");

    // 3.使用框架的一个明显的好处是高级的API可以用更简洁的代码完成更复杂的功能

    // 14--------------------
    // setTimeout() setInterval() 返回值 可以用于clear函数调用
    // 浏览器定位与导航 location.href: protocol,host,hostname,port,pathname,search/hash
    var isLocation = window.location === document.location; //总是返回true

    function urlArgs(){
        var args = {};
        var query = location.search.substring(1);
        var pairs = query.split("&");
        for(var i = 0; i < pairs.length; i++){
            var pos = pairs[i].indexOf('=');
            if(pos == -1) continue;
            var name = pairs[i].substring(0, pos);
            var value = pairs[i].substring(pos+1);
            value = decodeURIComponent(value);
            args[name] = value;
        }
        return args;
    }
    // 载入新的文档： assign(),replace(),reload(),直接把新的URL赋给location属性
    // 浏览历史：window.history.go(-2).back().forward();
    // 浏览器和屏幕信息：Navigator{appName,appVersion,userAgent,platform}
    // webkit: Safari或者Chrome,版本号是webkit的版本号
    // opera: Opera,版本号就是软件的版本号
    // mozilla: Firefox或者其他基于gecko内核的浏览器；版本号是gecko的版本号
    // msie: IE; 版本号就是软件的版本
    var browser = (function () {
        var s = navigator.userAgent.toLowerCase();
        var match = /(webkit)[\/]([\w.]+)/.exec(s) ||
                    /(opera)(?:.*version)?[\/]([\w.]+)/.exec(s) ||
                    /(msie)([\w.]+)/.exec(s) ||
                    !/compatible/.test(s) && /(mozilla)(?:.*? rv:([\w.]+))?/.exec(s) ||
                    [];
        return { name:match[1]||"", version: match[2] || "0"};
    })();
    console.log(navigator.userAgent.toLowerCase());
    console.log(browser);
    var $ = function (id) {
        return document.getElementById(id);
    };

    //

    // var w = window.open('test1.html','smallwin','width=400,height=350,status=yes,resizable=yes');

    // 15----------------this is the longest chapter of the book, like what I said in the very ahead
    // insertAdjacentHTML("beforebegin/afterdegin/beforeend/afterend",node)

    // scroll和scrollTo是一样的，scrollBy参数相对，scrollIntoView;window.location.hash
    // client~ 不含边框大小，内联元素全为0
    // 用offsetLeft 和 offsetTop来计算元素e的位置需要一个循环：
    function getElementPosition(elt) {
        var x = 0, y = 0;
        for (var e1 = elt; e1 != null; e1 = e1.offsetParent) {
            x += e1.offsetLeft;
            y += e1.offsetTop;
        }
        for (var e2 = elt.parentNode; e2 != null && e2.nodeType == 1; e2 = e2.parentNode) {
            x -= e2.scrollLeft;
            y -= e2.scrollTop;
        }
        return {x: x, y: y};
    }
    // 重点来了: document.write()


    // 16------------------


    // if(expression){ var j = 0 } j已经定义了，但是可能没有初始化
    // this is a useful function
    function out(x) {
        console.log(x);
    }

</script>
</html>